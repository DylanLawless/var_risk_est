gene_totals <- varRisEst_gene_scored %>%
group_by(genename) %>%
summarise(total_count = sum(count))
varRisEst_gene_scored <- varRisEst_gene_scored %>%
left_join(gene_totals, by = "genename") %>%
mutate(genename = reorder(genename, -total_count))
# Order stacking within each gene by increasing score
varRisEst_gene_scored <- varRisEst_gene_scored %>%
group_by(genename) %>%
arrange(score) %>%
mutate(score_factor = factor(score, levels = unique(score))) %>%
ungroup()
# Create horizontal stacked bar chart with segments ordered by score
p1 <- ggplot(varRisEst_gene_scored, aes(x = count, y = genename, fill = score, ,group = score_factor)) +
geom_bar(stat = "identity", position = "stack") +
scale_fill_gradient2(low = "navy", mid = "lightblue", high = "red", midpoint = 0) +
scale_y_discrete(breaks = function(x) x[seq(1, length(x), 100)]) +
labs(
# x = "Classifications per gene (count)",
y = "Gene name\n(every 100th)",
fill = "Score"
)
p1
p2 <- ggplot(varRisEst_gene_scored, aes(x = count, y = genename, fill = score, group = score_factor)) +
geom_bar(stat = "identity", position = "fill") +
scale_fill_gradient2(low = "navy", mid = "lightblue", high = "red", midpoint = 0) +
scale_x_continuous(labels = percent_format()) +
scale_y_discrete(breaks = function(x) x[seq(1, length(x), 100)]) +
labs(
# x = " Classifications per gene (%)",
y = "Gene name\n(every 100th)",
fill = "Score"
)
p1 + p2 +
plot_annotation(tag_levels = 'A') +
plot_layout(guides = 'collect') +
plot_layout(axis_titles = "collect")
p2
# Filter for rows with score > 0, then tally counts per gene
varRisEst_gene_scored_positive <- varRisEst_gene_scored %>%
filter(score > 0) %>%
group_by(genename) %>%
summarise(score_positive_total = sum(count), .groups = "drop") %>%
arrange(desc(score_positive_total))
# Filter for rows with score > 0, then tally counts per gene
top_ranks <- varRisEst_gene_scored_positive %>%
arrange(desc(score_positive_total)) %>%
slice_head(n = 15)
# Filter the data to include only the top 10 genes and set the factor levels
top_ranks <- varRisEst_gene_scored %>%
semi_join(top_ranks, by = "genename") %>%
mutate(genename = factor(genename, levels = top_ranks$genename))
# Plot horizontal stacked bar chart for the top 10 genes
p3 <- ggplot(top_ranks, aes(x = count, y = genename, fill = score, group = score_factor)) +
geom_bar(stat = "identity", position = "stack", color = "black") +
scale_fill_gradient2(low = "navy", mid = "lightblue", high = "red", midpoint = 0) +
labs(
# x = "Classifications per gene (count)",
y = "Gene name\n(Top 15 pathogenic count)",
fill = "Score"
)
p3
# Complex layouts can be created with the `design` argument
design <- "
123
144
"
patch1 <-
p_score + p1 + p2 + p3 + plot_layout(design = design)  +
plot_annotation(tag_levels = 'A',) +
plot_layout(guides = 'collect', axis_titles = "collect")
patch1
gene_summary <- varRisEst_gene_scored %>%
group_by(genename) %>%
summarise(
# 0-1,2-3,4,5,
score5 = sum(if_else(score == 5, count, 0L)),
score4 = sum(if_else(score >=3 & score <= 4, count, 0L)),
score2 = sum(if_else(score >= 0 & score <= 2, count, 0L)),
score0 = sum(if_else(score >= -5 & score <= -1, count, 0L)),
) %>%
ungroup() %>%
mutate(VariantCounts = paste(score5, score4, score2,score0, sep = " / "))
gene_summary
View(varRisEst_gene_scored)
varRisEst_gene_scored
View(varRisEst_gene_scored)
gene_summary
# gene_summary <- varRisEst_gene_scored %>%
#   group_by(genename) %>%
#   summarise(
#     Pathogenic = sum(if_else(score > 0, count, 0L)),
#     Other = sum(if_else(score <= 0, count, 0L))
#   ) %>%
#   ungroup() %>%
#   mutate(VariantCounts = paste(Pathogenic, Other, sep = " / "))
#
names(varRisEst_gene_scored)
gene_summary <- varRisEst_gene_scored %>%
group_by(genename) %>%
summarise(
# 0-1,2-3,4,5,
score5 = sum(if_else(score == 5, count, 0L)),
score4 = sum(if_else(score >=3 & score <= 4, count, 0L)),
score2 = sum(if_else(score >= 0 & score <= 2, count, 0L)),
score0 = sum(if_else(score >= -5 & score <= -1, count, 0L)),
) %>%
ungroup() %>%
mutate(VariantCounts = paste(score5, score4, score2,score0, sep = " / "))
max_pathogenic <- max(gene_summary$Pathogenic, na.rm = TRUE)
# gene_summary <- varRisEst_gene_scored %>%
#   group_by(genename) %>%
#   summarise(
#     Pathogenic = sum(if_else(score > 0, count, 0L)),
#     Other = sum(if_else(score <= 0, count, 0L))
#   ) %>%
#   ungroup() %>%
#   mutate(VariantCounts = paste(Pathogenic, Other, sep = " / "))
#
names(varRisEst_gene_scored)
gene_summary <- varRisEst_gene_scored %>%
group_by(genename) %>%
summarise(
# 0-1,2-3,4,5,
score5 = sum(if_else(score == 5, count, 0L)),
score4 = sum(if_else(score >=3 & score <= 4, count, 0L)),
score2 = sum(if_else(score >= 0 & score <= 2, count, 0L)),
score0 = sum(if_else(score >= -5 & score <= -1, count, 0L)),
) %>%
ungroup() %>%
mutate(VariantCounts = paste(score5, score4, score2,score0, sep = " / "))
gene_summary
gene_summary <- varRisEst_gene_scored %>%
group_by(genename) %>%
summarise(
# 0-1,2-3,4,5,
score5 = sum(if_else(score == 5, count, 0L)),
score4 = sum(if_else(score > 3 & score < 5, count, 0L)),
# score4 = sum(if_else(score >=3 & score <= 4, count, 0L)),
score2 = sum(if_else(score >= 0 & score <= 2, count, 0L)),
score0 = sum(if_else(score >= -5 & score <= -1, count, 0L)),
) %>%
ungroup() %>%
mutate(VariantCounts = paste(score5, score4, score2,score0, sep = " / "))
gene_summary
gene_summary <- varRisEst_gene_scored %>%
group_by(genename) %>%
summarise(
score5 = sum(if_else(score == 5, count, 0L)),
score4 = sum(if_else(score >= 3 & score < 5, count, 0L)),
score2 = sum(if_else(score > 0 & score < 3, count, 0L)),
score0 = sum(if_else(score >= -5 & score =< 0, count, 0L))
gene_summary <- varRisEst_gene_scored %>%
group_by(genename) %>%
summarise(
score5 = sum(if_else(score == 5, count, 0L)),
score4 = sum(if_else(score >= 3 & score < 5, count, 0L)),
score2 = sum(if_else(score > 0 & score < 3, count, 0L)),
score0 = sum(if_else(score >= -5 & score <= 0, count, 0L))
) %>%
ungroup() %>%
mutate(VariantCounts = paste(score5, score4, score2, score0, sep = " / "))
gene_summary
print("!! Sores like 4.5 were missing. New system here !!")
gene_summary <- varRisEst_gene_scored %>%
group_by(genename) %>%
summarise(
score5 = sum(if_else(score == 5, count, 0L)),
score4 = sum(if_else(score >= 3 & score < 5, count, 0L)),
score2 = sum(if_else(score > 0 & score < 3, count, 0L)),
score0 = sum(if_else(score >= -5 & score <= 0, count, 0L))
) %>%
ungroup() %>%
mutate(VariantCounts = paste(score5, score4, score2, score0, sep = " / "))
# Single binning step
varRisEst_gene_scored_binned <- varRisEst_gene_scored %>%
mutate(
score_bin = case_when(
score == 5 ~ "score5",
score >= 3 & score < 5 ~ "score4",
score > 0 & score < 3 ~ "score2",
score >= -5 & score <= 0 ~ "score0",
TRUE ~ "unassigned" # should never happen
)
)
# Now summarise based on the bin
gene_summary <- varRisEst_gene_scored_binned %>%
group_by(genename, score_bin) %>%
summarise(count_sum = sum(count), .groups = "drop") %>%
pivot_wider(
names_from = score_bin,
values_from = count_sum,
values_fill = 0
) %>%
mutate(
VariantCounts = paste(score5, score4, score2, score0, sep = " / ")
)
# Now summarise based on the bin
gene_summary <- varRisEst_gene_scored_binned %>%
group_by(genename, score_bin) %>%
summarise(count_sum = sum(count), .groups = "drop") %>%
tidyr::pivot_wider(
names_from = score_bin,
values_from = count_sum,
values_fill = 0
) %>%
mutate(
VariantCounts = paste(score5, score4, score2, score0, sep = " / ")
)
gene_summary
# Now summarise based on the bin
gene_summary <- varRisEst_gene_scored_binned %>%
mutate(
score_bin = case_when(
score == 5 ~ "score5",
score >= 3 & score < 5 ~ "score4",
score > 0 & score < 3 ~ "score2",
score >= -5 & score <= 0 ~ "score0",
TRUE ~ "unassigned"
)
) %>%
group_by(genename, score_bin) %>%
summarise(count_sum = sum(count), .groups = "drop") %>%
pivot_wider(
names_from = score_bin,
values_from = count_sum,
values_fill = 0
) %>%
select(genename, score5, score4, score2, score0) %>%  # force order
mutate(
VariantCounts = paste(score5, score4, score2, score0, sep = " / ")
)
# Now summarise based on the bin
gene_summary <- varRisEst_gene_scored_binned %>%
mutate(
score_bin = case_when(
score == 5 ~ "score5",
score >= 3 & score < 5 ~ "score4",
score > 0 & score < 3 ~ "score2",
score >= -5 & score <= 0 ~ "score0",
TRUE ~ "unassigned"
)
) %>%
group_by(genename, score_bin) %>%
summarise(count_sum = sum(count), .groups = "drop") %>%
tidyr::pivot_wider(
names_from = score_bin,
values_from = count_sum,
values_fill = 0
) %>%
select(genename, score5, score4, score2, score0) %>%  # force order
mutate(
VariantCounts = paste(score5, score4, score2, score0, sep = " / ")
)
gene_summary
# test that all accounted
unassigned <- varRisEst_gene_scored_binned %>%
filter(score_bin == "unassigned")
if (nrow(unassigned) == 0) {
print("All scores assigned correctly.")
} else {
print("There are unassigned scores!")
}
max_pathogenic <- max(gene_summary$Pathogenic, na.rm = TRUE)
max_total <- max(gene_summary$Pathogenic + gene_summary$Other, na.rm = TRUE)
max_pathogenic
max_total
gene_summary
varRisEst_summary <- merge(gene_summary, varRisEst_gene_scored_positive)
names(varRisEst_summary)
colnames(varRisEst_summary)[colnames(varRisEst_summary) == 'genename'] <- 'Genetic defect'
colnames(varRisEst_summary)[colnames(varRisEst_summary) == 'score5'] <- 'score5.VRE'
colnames(varRisEst_summary)[colnames(varRisEst_summary) == 'score4'] <- 'score4.VRE'
colnames(varRisEst_summary)[colnames(varRisEst_summary) == 'score2'] <- 'score2.VRE'
colnames(varRisEst_summary)[colnames(varRisEst_summary) == 'score0'] <- 'score0.VRE'
colnames(varRisEst_summary)[colnames(varRisEst_summary) == 'VariantCounts'] <- 'VariantCounts.VRE'
varRisEst_summary
getwd()
library(dplyr)
library(stringr)
library(purrr)
library(scales)
library(stringr)
library(patchwork)
library(ggplot2);theme_set(theme_bw())
varRisEst_gene <- readRDS(file= "../output/VarRiskEst_PanelAppRex_ID_398_gene_tally.Rds") # gene level
varRisEst_var <- readRDS(file= "../output/VarRiskEst_PanelAppRex_ID_398_gene_variants.Rds") # all variants
View(varRisEst_var)
# HPC large import ----
library(readr)
library(dplyr)
library(patchwork)
library(stringr)
library(ggplot2); theme_set(theme_bw())
path_data <- "../data/"
# Ensure the output directory exists
if (!dir.exists("../images/")) dir.create("../images/")
# source PanelAppRex ----
source("panelapprex_import.R")
PanelAppRex_ID <- as.numeric(398) # args[1] on HPC from launch script
print(paste("Now running panel ID:", PanelAppRex_ID))
# Select our panel data ----
df_par <- df_par |> dplyr::select(entity_name, panel_id, Inheritance, name)
df_par <- df_par |> filter(panel_id == PanelAppRex_ID) # IUIS PID
colnames(df_par)[colnames(df_par) == 'entity_name'] <- 'genename'
# UK population
population_size <- 69433632
# Define chromosomes to loop over
chromosomes <- c("")
# Start import data ----
header_line <- readLines("../data/nfkb1_head", n = 1)
header_line <- sub("^#", "", header_line)
header_fields <- strsplit(header_line, "\t")[[1]]
rm(header_line)
# Function to process each chunk of dbNSFP data.
# (Note: All cleaning steps below will only be performed once per chunk.)
process_db_chunk <- function(chunk, pos) {
# Assign column names from header_fields
colnames(chunk) <- header_fields
# Select relevant columns
chunk <- chunk %>% select(genename, `pos(1-based)`, gnomAD_genomes_AN, gnomAD_genomes_AF,
clinvar_clnsig, HGVSc_VEP, HGVSp_VEP)
# Replace missing values and convert allele frequency and number to numeric
chunk$gnomAD_genomes_AF[chunk$gnomAD_genomes_AF == "."] <- 0
chunk$gnomAD_genomes_AN[chunk$gnomAD_genomes_AN == "."] <- 0
chunk$gnomAD_genomes_AF <- as.numeric(chunk$gnomAD_genomes_AF)
# Remove rows with missing clinvar_clnsig
chunk <- chunk %>% filter(clinvar_clnsig != ".")
# Copy original columns to new ones with "_all" appended
chunk$HGVSc_VEP_all <- chunk$HGVSc_VEP
chunk$HGVSp_VEP_all <- chunk$HGVSp_VEP
chunk$genename_all  <- chunk$genename
# Keep only the first transcript allele for simplicity
chunk$HGVSc_VEP <- sapply(strsplit(as.character(chunk$HGVSc_VEP), ";"), `[`, 1)
chunk$HGVSp_VEP <- sapply(strsplit(as.character(chunk$HGVSp_VEP), ";"), `[`, 1)
chunk$genename   <- sapply(strsplit(as.character(chunk$genename), ";"), `[`, 1)
# Ensure character vector
chunk$HGVSc_VEP <- as.character(chunk$HGVSc_VEP)
chunk$HGVSp_VEP <- as.character(chunk$HGVSp_VEP)
chunk$genename <- as.character(chunk$genename)
return(chunk)
}
header_fields
# Function to process each chunk of dbNSFP data.
# (Note: All cleaning steps below will only be performed once per chunk.)
process_db_chunk <- function(chunk, pos) {
# Assign column names from header_fields
colnames(chunk) <- header_fields
# Select relevant columns
chunk <- chunk %>% select(genename, chr, `hg18_chr`, `hg19_chr`, `pos(1-based)`, gnomAD_genomes_AN, gnomAD_genomes_AF,
clinvar_clnsig, HGVSc_VEP, HGVSp_VEP)
# Replace missing values and convert allele frequency and number to numeric
chunk$gnomAD_genomes_AF[chunk$gnomAD_genomes_AF == "."] <- 0
chunk$gnomAD_genomes_AN[chunk$gnomAD_genomes_AN == "."] <- 0
chunk$gnomAD_genomes_AF <- as.numeric(chunk$gnomAD_genomes_AF)
# Remove rows with missing clinvar_clnsig
chunk <- chunk %>% filter(clinvar_clnsig != ".")
# Copy original columns to new ones with "_all" appended
chunk$HGVSc_VEP_all <- chunk$HGVSc_VEP
chunk$HGVSp_VEP_all <- chunk$HGVSp_VEP
chunk$genename_all  <- chunk$genename
# Keep only the first transcript allele for simplicity
chunk$HGVSc_VEP <- sapply(strsplit(as.character(chunk$HGVSc_VEP), ";"), `[`, 1)
chunk$HGVSp_VEP <- sapply(strsplit(as.character(chunk$HGVSp_VEP), ";"), `[`, 1)
chunk$genename   <- sapply(strsplit(as.character(chunk$genename), ";"), `[`, 1)
# Ensure character vector
chunk$HGVSc_VEP <- as.character(chunk$HGVSc_VEP)
chunk$HGVSp_VEP <- as.character(chunk$HGVSp_VEP)
chunk$genename <- as.character(chunk$genename)
return(chunk)
}
# List to accumulate results from all chromosomes
accumulated <- list()
# Define chunk callback that appends processed chunks to the global list
chunk_callback <- function(x, pos) {
accumulated[[length(accumulated) + 1]] <<- process_db_chunk(x, pos)
}
print(paste("Running on all chromosomes for panel ID:", PanelAppRex_ID))
for(chr in chromosomes) {
data_file <- sprintf("../data/nfkb1%s", chr) # mimics the chromosome-split version on HPC
message("Processing chromosome: ", chr)
read_delim_chunked(
file = data_file,
delim = "\t",
col_names = FALSE,  # header will be set in process_db_chunk
skip = 1,           # skip header in the main file
chunk_size = 100000,
callback = DataFrameCallback$new(chunk_callback)
)
}
# Combine all processed chunks into one data frame
df <- bind_rows(accumulated)
View(df)
# Function to process each chunk of dbNSFP data.
# (Note: All cleaning steps below will only be performed once per chunk.)
process_db_chunk <- function(chunk, pos) {
# Assign column names from header_fields
colnames(chunk) <- header_fields
# Select relevant columns
chunk <- chunk %>% select(genename, chr, `hg18_chr`, `hg19_chr`, `pos(1-based)`, gnomAD_genomes_AN, gnomAD_genomes_AF,
clinvar_clnsig, HGVSc_VEP, HGVSp_VEP)
# Replace missing values and convert allele frequency and number to numeric
chunk$gnomAD_genomes_AF[chunk$gnomAD_genomes_AF == "."] <- 0
chunk$gnomAD_genomes_AN[chunk$gnomAD_genomes_AN == "."] <- 0
chunk$gnomAD_genomes_AF <- as.numeric(chunk$gnomAD_genomes_AF)
# Remove rows with missing clinvar_clnsig
chunk <- chunk %>% filter(clinvar_clnsig != ".")
# Copy original columns to new ones with "_all" appended
chunk$HGVSc_VEP_all <- chunk$HGVSc_VEP
chunk$HGVSp_VEP_all <- chunk$HGVSp_VEP
chunk$genename_all  <- chunk$genename
# Keep only the first transcript allele for simplicity
chunk$HGVSc_VEP <- sapply(strsplit(as.character(chunk$HGVSc_VEP), ";"), `[`, 1)
chunk$HGVSp_VEP <- sapply(strsplit(as.character(chunk$HGVSp_VEP), ";"), `[`, 1)
chunk$genename   <- sapply(strsplit(as.character(chunk$genename), ";"), `[`, 1)
# Ensure character vector
chunk$HGVSc_VEP <- as.character(chunk$HGVSc_VEP)
chunk$HGVSp_VEP <- as.character(chunk$HGVSp_VEP)
chunk$genename <- as.character(chunk$genename)
return(chunk)
}
# List to accumulate results from all chromosomes
accumulated <- list()
# Define chunk callback that appends processed chunks to the global list
chunk_callback <- function(x, pos) {
accumulated[[length(accumulated) + 1]] <<- process_db_chunk(x, pos)
}
print(paste("Running on all chromosomes for panel ID:", PanelAppRex_ID))
for(chr in chromosomes) {
data_file <- sprintf("../data/nfkb1%s", chr) # mimics the chromosome-split version on HPC
message("Processing chromosome: ", chr)
read_delim_chunked(
file = data_file,
delim = "\t",
col_names = FALSE,  # header will be set in process_db_chunk
skip = 1,           # skip header in the main file
chunk_size = 100000,
callback = DataFrameCallback$new(chunk_callback)
)
}
# Combine all processed chunks into one data frame
df <- bind_rows(accumulated)
print(paste("Binding all rows complete for panel ID:", PanelAppRex_ID))
# simple version gene 1
# df <- read.table("../data/nfkb1",
#                  sep = "\t",
#                  header = FALSE,
#                  stringsAsFactors = FALSE,
#                  fill = TRUE)
# colnames(df) <- header_fields
df_gene1 <- df
print(paste("Running on all chromosomes for panel ID:", PanelAppRex_ID))
for(chr in chromosomes) {
data_file <- sprintf("../data/cftr%s", chr) # mimics the chromosome-split version on HPC
message("Processing chromosome: ", chr)
read_delim_chunked(
file = data_file,
delim = "\t",
col_names = FALSE,  # header will be set in process_db_chunk
skip = 1,           # skip header in the main file
chunk_size = 100000,
callback = DataFrameCallback$new(chunk_callback)
)
}
# Combine all processed chunks into one data frame
df <- bind_rows(accumulated)
print(paste("Binding all rows complete for panel ID:", PanelAppRex_ID))
# colnames(df) <- header_fields
df_gene2 <- df
df <- rbind(df_gene1, df_gene2)
# get Inheritance from PanelAppRex
dfx <- merge(df, df_par)
dfx <- merge(df, df_par, by = "genename")
# If no known variants per clinsig, consider a minimal risk with 1 de novo ----
df <- df %>%
group_by(genename) %>%
mutate(
gnomAD_genomes_AF = as.numeric(gnomAD_genomes_AF),
gnomAD_genomes_AN = as.numeric(gnomAD_genomes_AN),
max_an = max(gnomAD_genomes_AN, na.rm = TRUE),
synth_flag = gnomAD_genomes_AF == 0,
gnomAD_genomes_AF = ifelse(synth_flag, 1 / (max_an + 1), gnomAD_genomes_AF)
) %>%
ungroup()
# Run this but skip it is special case if we want a variant that is not on gnomad
if (!exists("KEPP_ALL_FOR_VALIDATION_SEARCH") || !KEPP_ALL_FOR_VALIDATION_SEARCH) {
message("Running de novo estimate grouping and filtering step.")
df <- df %>%
group_by(genename, clinvar_clnsig) %>%
group_modify(~ {
# Always keep this comment as it is key to a subtle step.
# For each group defined by genename and clinvar_clnsig:
#   - If there is at least one row that is not synthetic (synth_flag == FALSE),
#     then keep only the non-synthetic rows.
#   - Otherwise, if all rows in the group are synthetic, keep only one synthetic row.
if (any(!.x$synth_flag)) {
.x %>% filter(!synth_flag)
} else {
.x %>% slice(1)
}
}) %>%
ungroup()
} else {
message("Skipping de novo estimate grouping and filtering step due to KEPP_ALL_FOR_VALIDATION_SEARCH being TRUE.")
}
names(df)
# Inheritance and expected cases ----
# For AR calculations, compute the total allele frequency per gene
df <- df %>%
group_by(genename) %>%
mutate(total_AF = sum(gnomAD_genomes_AF, na.rm = TRUE)) %>%
ungroup()
